# unsafe用法

1. 用于修饰函数fn
	- unsafe函数具有"传递性"
2. 用于修饰代码块
	- 对裸指针执行解引用操作
	- 读写可变静态变量
	- 读union或者写union的非Copy操作
	- 调用unsafe函数
3. 用于修饰trait
4. 用于修饰impl

# 裸指针

- 创建裸指针安全, 对裸指针解引用不安全, 必须在unsafe语句块中完成

# 协变/逆变

> 类型构造器保证了参数的子类型关系, 就是协变, 如果逆转了参数的子类型系统, 就是逆变
> Rust不支持普通泛型参数类型的协变和逆变, 只对生命周期泛型参数存在协变和逆变

- 使用`<:` 符号记录子类型关系, 对于泛型类型C<T>
	- 协变: 如果T1<:T2,是满足C<T1> <: C<T2>, 则C对于参数T是协变关系
	- 逆变: 如果T1<:T2时满足C<T2> <: C<T1>, 则C对于参数T是逆变关系
- Box<&'static str>类型到Box<&'a str>类型的转换是安全的. Box<T>类型对T参数具有协变关系

# 未定义行为

> 只有unsafe能造成UB(undefined behavior)

- 数据竞争
- 解引用空指针或者悬空指针
- 使用未对齐的指针读写内存而不是使用read_unaligned或者write_unaligned
- 读取未初始化内存
- 破坏了指针别名规则
- 通过共享引用修改变量
- 调用编译器内置函数制造UB
- 给内置类型赋予非法值
- ...
