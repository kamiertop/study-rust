## 变量声明
> `let varibale: i32 = 100;`
- 语法分析更容易, 语法歧义更少, 语法分析器更容易编写
- 方便引入类型推导, 变量声明中, 最重要的变量本身
- 模式结构
- 变量必须为合理初始化才能使用
- 一个变量的类型必须在编译器确定
- 只允许**局部变量/全局变量**实现类型推导, 全局变量必须当场初始化而函数签名具有全局性影响
  - 函数签名等场景不允许, 如果使用自动类型推导, 可能导致某个调用的地方使用方式发生变化, 它的参数, 返回值类型就发生了变化
- 静态变量: 生命周期为整个程序, 生命周期永远是 `'static`, 占用的内存空间也不会在执行过程中回收
  - 带有mut修饰的全局变量, 在使用的时候必须使用unsafe关键字
  - 不能在声明时调用普通函数
  - Rust不允许用户在main函数之前或者之后执行自己的代码, 所以比较复杂的static变量的初始化一般需要使用lazy方式, 在第一次使用的时候初始化
  ```rust
  fn main(){
    static mut G2 : i32 = 4;
    unsafe {
        G2 = 5;
        println!("{}",G2);
    }
  }
  // 全局变量的内存不是分配在当前函数栈上, 函数退出的时候, 并不会销毁全局变量占用的内存空间, 程序退出才会回收
  ```
- `const`声明常量, 不是变量.
  - 常量的初始化表达式一定要是一个编译器常量, 不能是运行期的值
  - 编译器并不一定会给const常量分配内存空间, 编译期间, 可能会被内联优化
## 基本数据类型
- `bool`
- `char`: 目的是描述任意一个unicode字符, 占据的内存空间不是1个字节, 是4个字节
  - byte: u8
  - []byte: [u8;len]
- 整数溢出
  - debug模式: 自动 插入整数溢出检查, 一旦溢出, panic
  - release模式: 不检查整数溢出, 采用自动舍弃高位的方式
  - `checked_*,saturating_*, wrapping_*` 可以更精确地自主控制整数溢出的行为
- 浮点数
  - `Infinite`: 无穷大
  - `Nan`: 不是数字
- 指针类型
  - `&T`:       指向类型T的借用指针, 也被称为引用, 无权释放内存, 无权写数据
  - `Box<T>`:   指向类型T的, 具有所有权的指针, 有权释放内存
  - `&mut T`:   指向类型T的mut型借用指针, 无权释放内存, 有权写数据
  - `*const T`: 指向类型T的只读裸指针, 没有生命周期信息, 无权写数据
  - `*mut T`:   指向类型T的可读写裸指针, 没有声明周期信息, 有权写数据
  - `Rc<T>`:    指向类型T的引用计数指针, 共享所有权, 线程不安全
  - `Arc<T>`:   指向类型T的原子型引用计数指针, 共享所有权, 线程安全
  - `Cow<'a,T>`:Clone-on-write, 写时复制指针, 可能是借用指针或者具有所有权的指针
- 类型转换, 使用as关键字: 编译器认为合理的类型转换