## 变量声明
> `let varibale: i32 = 100;`
- 语法分析更容易, 语法歧义更少, 语法分析器更容易编写
- 方便引入类型推导, 变量声明中, 最重要的变量本身
- 模式结构
- 变量必须为合理初始化才能使用
- 一个变量的类型必须在编译器确定
- 只允许**局部变量/全局变量**实现类型推导, 全局变量必须当场初始化而函数签名具有全局性影响
  - 函数签名等场景不允许, 如果使用自动类型推导, 可能导致某个调用的地方使用方式发生变化, 它的参数, 返回值类型就发生了变化
- 静态变量: 生命周期为整个程序, 生命周期永远是 `'static`, 占用的内存空间也不会在执行过程中回收
  - 带有mut修饰的全局变量, 在使用的时候必须使用unsafe关键字
  - 不能在声明时调用普通函数
  - Rust不允许用户在main函数之前或者之后执行自己的代码, 所以比较复杂的static变量的初始化一般需要使用lazy方式, 在第一次使用的时候初始化
  ```rust
  fn main(){
    static mut G2 : i32 = 4;
    unsafe {
        G2 = 5;
        println!("{}",G2);
    }
  }
  // 全局变量的内存不是分配在当前函数栈上, 函数退出的时候, 并不会销毁全局变量占用的内存空间, 程序退出才会回收
  ```
- `const`声明常量, 不是变量.
  - 常量的初始化表达式一定要是一个编译器常量, 不能是运行期的值
  - 编译器并不一定会给const常量分配内存空间, 编译期间, 可能会被内联优化
## 基本数据类型
- `bool`
- `char`: 目的是描述任意一个unicode字符, 占据的内存空间不是1个字节, 是4个字节
  - byte: u8
  - []byte: [u8;len]
- 整数溢出
  - debug模式: 自动 插入整数溢出检查, 一旦溢出, panic
  - release模式: 不检查整数溢出, 采用自动舍弃高位的方式
  - `checked_*,saturating_*, wrapping_*` 可以更精确地自主控制整数溢出的行为
- 浮点数
  - `Infinite`: 无穷大
  - `Nan`: 不是数字
- 指针类型
  - `&T`:       指向类型T的借用指针, 也被称为引用, 无权释放内存, 无权写数据
  - `Box<T>`:   指向类型T的, 具有所有权的指针, 有权释放内存
  - `&mut T`:   指向类型T的mut型借用指针, 无权释放内存, 有权写数据
  - `*const T`: 指向类型T的只读裸指针, 没有生命周期信息, 无权写数据
  - `*mut T`:   指向类型T的可读写裸指针, 没有声明周期信息, 有权写数据
  - `Rc<T>`:    指向类型T的引用计数指针, 共享所有权, 线程不安全
  - `Arc<T>`:   指向类型T的原子型引用计数指针, 共享所有权, 线程安全
  - `Cow<'a,T>`:Clone-on-write, 写时复制指针, 可能是借用指针或者具有所有权的指针
- 类型转换, 使用as关键字: 编译器认为合理的类型转换
## 复合数据类型
- `let empty: () = ();` 单元类型
- 空元组(unit类型)和空结构体一样, 都是占用0内存空间
- `struct Color(i32,i32,i32);` tuple struct
```rust
// 被想象成这样的结构体
struct Color{
    0: i32,
    1: i32,
    2: i32,
}
```
- `tuple, struct, tuple struct`: 有一致的内存对齐策略, 一致的占用空间规则
- `tuple struct`一个有用的场景是基于一个类型创建一个新的类型, 类似于Go中的`type H map[string]any`
  - `struct NewInt(int)`, 这个新的类型 `NewInt` 可以有不同的方法, 满足不同的trait
- Rust的`enum`类型的变量需要区分它里面的数据究竟是哪种变体, 所以它包含了一个内部的`tag`标记来描述当前变量属于哪种类型, 但是对用户不可见
  - `enum`会进行内存对齐操作
- 类型递归定义: Rust符合类型允许递归定义
```rust
struct Recursive {
	data: i32,
	rec: Recursive
}
// 编译出错, 因为Recursive的内存布局无法计算, 公式如下
// size_of::<Recursive>() == 4 + size_of::<Recursive>(), 实数范围内无解, 我想其他语言也是一样! 
```