- 泛型是指把类型抽象成一种参数, 数据和算法都针对这种抽象的类型参数来实现, 而不是针对具体类型, 需要真正使用的时候, 再具体化,
  实例化类型参数
- 所有的泛型参数必须是被真的被使用的, 下面的实例报错

```rust
fn main() {
	struct Num<T> {
		data: i32,
	}
}
```

- 编译器生成代码的时候, 它会为每一个不同的泛型参数生成不同的代码
- 一般情况下, 调用泛型参数可以不指定泛型参数类型, 编译器可以通过类型推导自动判断
- 函数重载以及泛型函数都是在编译阶段静态分派的
- enum会在执行阶段判断当前成员是哪个变体
- impl块中的泛型, 先声明, 再使用, impl块中出现的泛型参数, 需要在impl关键字后面用尖括号声明

```rust
impl<T, U> Into<U> for T
	where U: From<T>
{
	fn into(self) -> U {
		U::from(self)
	}
}    
```

- 尖括号中存在的泛型参数, 是输入类型参数, 用于决定匹配哪个impl版本的参数
- trait内部存在的关联类型, 是输出类型参数, 由输入类型参数和Self类型决定的参数类型
- 泛型特化
	- 性能优化
	- 代码重用
	- 为高校继承铺路